<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ProcessedTemplate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">WrzasqPl CodePipeline automation macro</a> &gt; <a href="index.source.html" class="el_package">pl.wrzasq.lambda.macro.pipeline.multistagecd.template</a> &gt; <span class="el_source">ProcessedTemplate.java</span></div><h1>ProcessedTemplate.java</h1><pre class="source lang-java linenums">// Generated by delombok at Tue Mar 31 19:56:06 UTC 2020
/*
 * This file is part of the pl.wrzasq.lambda.
 *
 * @license http://mit-license.org/ The MIT license
 * @copyright 2020 © by Rafał Wrzeszcz - Wrzasq.pl.
 */
package pl.wrzasq.lambda.macro.pipeline.multistagecd.template;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.stream.Collectors;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pl.wrzasq.commons.aws.cloudformation.macro.TemplateDefinition;
import pl.wrzasq.commons.aws.cloudformation.macro.TemplateUtils;
import pl.wrzasq.lambda.json.ObjectMapperFactory;
import pl.wrzasq.lambda.macro.pipeline.multistagecd.model.PipelineAction;
import pl.wrzasq.lambda.macro.pipeline.multistagecd.model.PipelineArtifact;
import pl.wrzasq.lambda.macro.pipeline.multistagecd.model.PipelineConfiguraiton;
import pl.wrzasq.lambda.macro.pipeline.multistagecd.model.PipelineDefinition;
import pl.wrzasq.lambda.macro.pipeline.multistagecd.model.PipelineStage;
import pl.wrzasq.lambda.macro.pipeline.multistagecd.model.codepipeline.ActionTypeId;

/**
 * Contains template structure after macro logic transformation.
 */
public class ProcessedTemplate implements TemplateDefinition {
    /**
     * Artificial &quot;Pipeline&quot; section.
     */
    private static final String SECTION_PIPELINE = &quot;Pipeline&quot;;
    /**
     * !Ref &quot;AWS::NoValue&quot; expression.
     */
<span class="fc" id="L44">    private static final Object NO_VALUE = TemplateUtils.ref(&quot;AWS::NoValue&quot;);</span>
    /**
     * CloudFormation artifact path separator.
     */
    private static final String ARTIFACT_SEPARATOR = &quot;::&quot;;
    /**
     * Values converter.
     */
<span class="fc" id="L52">    private static ObjectMapper objectMapper = ObjectMapperFactory.createObjectMapper();</span>
    /**
     * Logger.
     */
<span class="fc" id="L56">    private static Logger logger = LoggerFactory.getLogger(ProcessedTemplate.class);</span>
    /**
     * Template structure.
     */
    private Map&lt;String, Object&gt; template;

    /**
     * Template initializer.
     *
     * @param input Initial template structure.
     */
<span class="fc" id="L67">    public ProcessedTemplate(Map&lt;String, Object&gt; input) {</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">        this.template = input.containsKey(ProcessedTemplate.SECTION_PIPELINE) ? this.processTemplate(input) : </span>
        // nothing to process
<span class="fc" id="L70">        input;</span>
<span class="fc" id="L71">    }</span>

    /**
     * Builds pipeline resource.
     *
     * @param input Initial template structure.
     * @return Template state after processing.
     */
    private Map&lt;String, Object&gt; processTemplate(Map&lt;String, Object&gt; input) {
<span class="fc" id="L80">        logger.info(&quot;Found pipeline definition.&quot;);</span>
        // default values are set in the classes
<span class="fc" id="L82">        var pipeline = ProcessedTemplate.objectMapper.convertValue(input.get(ProcessedTemplate.SECTION_PIPELINE), PipelineDefinition.class);</span>
<span class="fc" id="L83">        input.remove(ProcessedTemplate.SECTION_PIPELINE);</span>
<span class="fc" id="L84">        var output = new HashMap&lt;&gt;(input);</span>
        // pipeline metadata setup
<span class="fc" id="L86">        output.put(TemplateUtils.SECTION_CONDITIONS, this.buildConditions(TemplateUtils.asMap(input.computeIfAbsent(TemplateUtils.SECTION_CONDITIONS, key -&gt; new HashMap&lt;&gt;())), pipeline.getConfig()));</span>
<span class="fc" id="L87">        output.put(TemplateUtils.SECTION_RESOURCES, this.buildResources(TemplateUtils.asMap(input.computeIfAbsent(TemplateUtils.SECTION_RESOURCES, key -&gt; new HashMap&lt;&gt;())), pipeline));</span>
<span class="fc" id="L88">        return output;</span>
    }

    /**
     * Builds conditions used by pipeline.
     *
     * @param conditions Initial conditions.
     * @param config Pipeline config.
     * @return Template conditions.
     */
    private Map&lt;String, Object&gt; buildConditions(Map&lt;String, Object&gt; conditions, PipelineConfiguraiton config) {
<span class="fc" id="L99">        conditions.put(config.getHasCheckoutStepConditionName(), ProcessedTemplate.buildBooleanCondition(config.getHasCheckoutStepParameterName()));</span>
<span class="fc" id="L100">        conditions.put(config.getHasNextStageConditionName(), ProcessedTemplate.buildBooleanCondition(config.getHasNextStageParameterName()));</span>
<span class="fc" id="L101">        conditions.put(config.getRequiresManualApprovalConditionName(), Collections.singletonMap(&quot;Fn::And&quot;, Arrays.asList(Collections.singletonMap(&quot;Condition&quot;, config.getHasNextStageConditionName()), ProcessedTemplate.buildBooleanCondition(config.getRequiresManualApprovalParameterName()))));</span>
<span class="fc" id="L102">        return conditions;</span>
    }

    /**
     * Builds resources used by pipeline.
     *
     * @param resources Resources container.
     * @param pipeline Pipeline definition.
     * @return Template conditions.
     */
    private Map&lt;String, Object&gt; buildResources(Map&lt;String, Object&gt; resources, PipelineDefinition pipeline) {
<span class="fc" id="L113">        var config = pipeline.getConfig();</span>
<span class="fc" id="L114">        resources.put(config.getResourceName(), this.buildPipelineDefinition(pipeline));</span>
        // GitHub webhook
<span class="pc bpc" id="L116" title="1 of 4 branches missed.">        if (config.getWebhookAuthenticationType() != null &amp;&amp; config.getWebhookSecretToken() != null) {</span>
<span class="fc" id="L117">            resources.put(String.format(&quot;%sWebhook&quot;, config.getResourceName()), this.buildWebhookDefinition(config, pipeline.getSources().keySet().iterator().next()));</span>
        }
<span class="fc" id="L119">        return resources;</span>
    }

    /**
     * Build pipeline definition.
     *
     * @param pipeline Pipeline definition.
     * @return Resource definition.
     */
    private Map&lt;String, Object&gt; buildPipelineDefinition(PipelineDefinition pipeline) {
<span class="fc" id="L129">        var config = pipeline.getConfig();</span>
<span class="fc" id="L130">        var artifacts = pipeline.getArtifacts();</span>
<span class="fc" id="L131">        var stages = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L132">        stages.add(this.buildSourceStage(config, pipeline.getSources(), artifacts));</span>
<span class="fc" id="L133">        stages.addAll(this.buildStages(pipeline.getStages()));</span>
<span class="fc" id="L134">        stages.add(this.buildManualApprovalStage(config));</span>
<span class="fc" id="L135">        stages.add(this.buildPromoteStage(config, artifacts));</span>
        // finalize properties
<span class="fc" id="L137">        var properties = new HashMap&lt;&gt;(pipeline.getProperties());</span>
<span class="fc" id="L138">        properties.put(&quot;Stages&quot;, stages);</span>
<span class="fc" id="L139">        return TemplateUtils.generateResource(&quot;CodePipeline::Pipeline&quot;, properties, null);</span>
    }

    /**
     * Builds sources stage.
     *
     * @param config Pipeline configuration.
     * @param sources Source locations.
     * @param artifacts Previous stage artifacts.
     * @return Stage definition.
     */
    private Map&lt;String, Object&gt; buildSourceStage(PipelineConfiguraiton config, Map&lt;String, Map&lt;String, Object&gt;&gt; sources, Map&lt;String, PipelineArtifact&gt; artifacts) {
<span class="fc" id="L151">        return CodePipelineUtils.buildStage(&quot;Source&quot;, ProcessedTemplate.fnIf(config.getHasCheckoutStepConditionName(), this.buildCheckoutSources(sources), this.buildPromotedSources(artifacts)));</span>
    }

    /**
     * Builds sources action steps.
     *
     * @param sources Source locations.
     * @return Stage actions.
     */
    private Object buildCheckoutSources(Map&lt;String, Map&lt;String, Object&gt;&gt; sources) {
<span class="fc" id="L161">        var steps = new ArrayList&lt;&gt;(sources.size());</span>
        // keeping order to avoid structure changes in CloudFormation
<span class="fc bfc" id="L163" title="All 2 branches covered.">        for (var id : new TreeSet&lt;&gt;(sources.keySet())) {</span>
<span class="fc" id="L164">            steps.add(ProcessedTemplate.populateActionDefinition(sources.get(id), id, null, Collections.emptyMap(), Collections.emptyList(), Collections.singletonList(id), null));</span>
<span class="fc" id="L165">        }</span>
<span class="fc" id="L166">        return steps;</span>
    }

    /**
     * Builds sources action steps.
     *
     * @param artifacts Previous stage artifacts.
     * @return Stage actions.
     */
    private Object buildPromotedSources(Map&lt;String, PipelineArtifact&gt; artifacts) {
<span class="fc" id="L176">        var steps = new ArrayList&lt;&gt;(artifacts.size());</span>
<span class="fc" id="L177">        var runOrder = 0;</span>
        /*
        having sources in reverse direction than in promote step, makes us sure that each next stage pipeline is
        launched only when all previous stage artifacts are properly uploaded
         */
<span class="fc bfc" id="L182" title="All 2 branches covered.">        for (var id : new TreeSet&lt;&gt;(artifacts.keySet()).descendingSet()) {</span>
<span class="fc" id="L183">            var artifact = artifacts.get(id);</span>
<span class="fc" id="L184">            var type = ActionTypeId.s3Source();</span>
<span class="fc" id="L185">            var actionConfig = new HashMap&lt;String, Object&gt;();</span>
<span class="fc" id="L186">            actionConfig.put(&quot;S3Bucket&quot;, artifact.getSourceBucketName());</span>
<span class="fc" id="L187">            actionConfig.put(&quot;S3ObjectKey&quot;, artifact.getObjectKey());</span>
<span class="fc" id="L188">            steps.add(ProcessedTemplate.buildActionDefinition(id, type, actionConfig, Collections.emptyList(), Collections.singletonList(id), ++runOrder));</span>
<span class="fc" id="L189">        }</span>
<span class="fc" id="L190">        return steps;</span>
    }

    /**
     * Builds pipelines stage definition.
     *
     * @param stages Stages definitions.
     * @return Stages definition.
     */
    private List&lt;Object&gt; buildStages(List&lt;PipelineStage&gt; stages) {
<span class="fc bfc" id="L200" title="All 2 branches covered.">        return stages.stream().map(stage -&gt; stage.getCondition() == null ? this.buildStage(stage) : ProcessedTemplate.fnIf(stage.getCondition(), this.buildStage(stage), ProcessedTemplate.NO_VALUE)).collect(Collectors.toList());</span>
    }

    /**
     * Builds manual approval stage definition.
     *
     * @param config Pipeline configuration.
     * @return Stage definition.
     */
    private Object buildManualApprovalStage(PipelineConfiguraiton config) {
<span class="fc" id="L210">        return ProcessedTemplate.fnIf(config.getRequiresManualApprovalConditionName(), CodePipelineUtils.buildStage(&quot;Review&quot;, Collections.singletonList(ProcessedTemplate.buildActionDefinition(&quot;Approval&quot;, ActionTypeId.manualApproval(), Collections.emptyMap(), Collections.emptyList(), Collections.emptyList(), null))), ProcessedTemplate.NO_VALUE);</span>
    }

    /**
     * Builds artifacts promotion stage definition.
     *
     * @param config Pipeline configuration.
     * @param artifacts Artifacts configuration.
     * @return Stage definition.
     */
    private Object buildPromoteStage(PipelineConfiguraiton config, Map&lt;String, PipelineArtifact&gt; artifacts) {
<span class="fc" id="L221">        var steps = new ArrayList&lt;&gt;(artifacts.size());</span>
<span class="fc" id="L222">        var runOrder = 0;</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">        for (var id : new TreeSet&lt;&gt;(artifacts.keySet())) {</span>
<span class="fc" id="L224">            var artifact = artifacts.get(id);</span>
<span class="fc" id="L225">            var type = ActionTypeId.s3Deploy();</span>
<span class="fc" id="L226">            var actionConfig = new HashMap&lt;String, Object&gt;();</span>
<span class="fc" id="L227">            actionConfig.put(&quot;BucketName&quot;, artifact.getNextBucketName());</span>
<span class="fc" id="L228">            actionConfig.put(&quot;ObjectKey&quot;, artifact.getObjectKey());</span>
<span class="fc" id="L229">            actionConfig.put(&quot;Extract&quot;, false);</span>
            // this shifts ownership to target account in case (usual scenario) of cross-account deployment
<span class="fc" id="L231">            actionConfig.put(&quot;CannedACL&quot;, &quot;bucket-owner-full-control&quot;);</span>
<span class="fc" id="L232">            steps.add(ProcessedTemplate.buildActionDefinition(id, type, actionConfig, Collections.singletonList(id), Collections.emptyList(), ++runOrder));</span>
<span class="fc" id="L233">        }</span>
<span class="fc" id="L234">        return ProcessedTemplate.fnIf(config.getHasNextStageConditionName(), CodePipelineUtils.buildStage(&quot;Promote&quot;, steps), ProcessedTemplate.NO_VALUE);</span>
    }

    /**
     * Builds pipeline stage definition structure.
     *
     * @param stage Stage setup.
     * @return CodePipeline stage definition.
     */
    private Map&lt;String, Object&gt; buildStage(PipelineStage stage) {
<span class="fc" id="L244">        var actions = stage.getActions();</span>
<span class="fc" id="L245">        actions.forEach(ProcessedTemplate::normalizeAction);</span>
<span class="fc" id="L246">        ProcessedTemplate.orderActions(actions);</span>
<span class="fc" id="L247">        return CodePipelineUtils.buildStage(stage.getName(), actions.stream().map(this::buildAction).collect(Collectors.toList()));</span>
    }

    /**
     * Normalizes all actions.
     *
     * @param action Action setup.
     */
    private static void normalizeAction(PipelineAction action) {
<span class="fc bfc" id="L256" title="All 2 branches covered.">        if (action.getType() == null) {</span>
<span class="fc" id="L257">            action.setType(ActionTypeId.cloudFormationDeploy());</span>
        }
<span class="fc" id="L259">        action.setInputs(ProcessedTemplate.detectInputArtifacts(action));</span>
<span class="fc" id="L260">    }</span>

    /**
     * Orders all actions.
     *
     * @param actions Stage actions.
     */
    private static void orderActions(List&lt;PipelineAction&gt; actions) {
<span class="fc" id="L268">        var visited = new HashSet&lt;PipelineAction&gt;();</span>
<span class="fc" id="L269">        var outputs = new HashMap&lt;String, PipelineAction&gt;();</span>
<span class="fc" id="L270">        actions.forEach(action -&gt; action.getOutputs().forEach(input -&gt; outputs.put(input, action)));</span>
<span class="fc" id="L271">        actions.forEach(action -&gt; ProcessedTemplate.calculateActionOrder(action, visited, outputs));</span>
<span class="fc" id="L272">    }</span>

    /**
     * Calculates action order.
     *
     * @param action Current subject action.
     * @param visited Current state markers.
     * @param outputs Output artifacts mapping.
     */
    private static void calculateActionOrder(PipelineAction action, Set&lt;PipelineAction&gt; visited, Map&lt;String, PipelineAction&gt; outputs) {
        // already calculated
<span class="fc bfc" id="L283" title="All 2 branches covered.">        if (action.getRunOrder() != null) {</span>
<span class="fc" id="L284">            return;</span>
        }
<span class="fc bfc" id="L286" title="All 2 branches covered.">        if (visited.contains(action)) {</span>
<span class="fc" id="L287">            throw new IllegalArgumentException(String.format(&quot;Circular artifact dependency for %s.&quot;, action.getName()));</span>
        }
<span class="fc" id="L289">        visited.add(action);</span>
        
        // dependencies from outside of stage not need to be considered
<span class="fc bfc" id="L292" title="All 2 branches covered.">        action.getInputs().stream().filter(outputs::containsKey).peek(input -&gt; ProcessedTemplate.calculateActionOrder(outputs.get(input), visited, outputs)).map(input -&gt; outputs.get(input).getRunOrder()).mapToInt(order -&gt; (order == null ? 1 : order) + 1).max().ifPresent(action::setRunOrder);</span>
<span class="fc" id="L293">        visited.remove(action);</span>
<span class="fc" id="L294">    }</span>

    /**
     * Builds pipeline stage action definition structure.
     *
     * @param action Stage setup.
     * @return CodePipeline action definition.
     */
    private Map&lt;String, Object&gt; buildAction(PipelineAction action) {
<span class="fc" id="L303">        return ProcessedTemplate.buildActionDefinition(action.getName(), action.getType(), action.getConfiguration(), action.getInputs(), action.getOutputs(), action.getRunOrder());</span>
    }

    /**
     * Builds list of all used input artifacts.
     *
     * @param action Action definition.
     * @return List of input artifacts.
     */
    private static List&lt;String&gt; detectInputArtifacts(PipelineAction action) {
<span class="fc" id="L313">        var inputs = action.getInputs();</span>
        // check TemplatePath source artifact
<span class="fc" id="L315">        var config = action.getConfiguration();</span>
<span class="fc" id="L316">        var value = config.get(&quot;TemplatePath&quot;);</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">        if (value instanceof String) {</span>
<span class="fc" id="L318">            inputs.add(((String) value).split(ProcessedTemplate.ARTIFACT_SEPARATOR)[0]);</span>
        }
        // check TemplateConfiguration source artifact
<span class="fc" id="L321">        value = config.get(&quot;TemplateConfiguration&quot;);</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">        if (value instanceof String) {</span>
<span class="fc" id="L323">            inputs.add(((String) value).split(ProcessedTemplate.ARTIFACT_SEPARATOR)[0]);</span>
        }
<span class="fc" id="L325">        return inputs;</span>
    }

    /**
     * Builds pipeline action definition structure.
     *
     * @param actionName Action name.
     * @param type Action type.
     * @param configuration Custom options.
     * @param inputs Input artifacts list.
     * @param outputs Output artifacts list.
     * @param runOrder Execution order.
     * @return CodePipeline stage definition.
     */
    private static Map&lt;String, Object&gt; buildActionDefinition(String actionName, ActionTypeId type, Map&lt;String, Object&gt; configuration, List&lt;String&gt; inputs, List&lt;String&gt; outputs, Integer runOrder) {
<span class="fc" id="L340">        return ProcessedTemplate.populateActionDefinition(new HashMap&lt;&gt;(), actionName, type, configuration, inputs, outputs, runOrder);</span>
    }

    /**
     * Populates pipeline action definition structure.
     *
     * @param action Action configuration.
     * @param actionName Action name.
     * @param type Action type.
     * @param configuration Custom options.
     * @param inputs Input artifacts list.
     * @param outputs Output artifacts list.
     * @param runOrder Execution order.
     * @return CodePipeline stage definition.
     */
    private static Map&lt;String, Object&gt; populateActionDefinition(Map&lt;String, Object&gt; action, String actionName, ActionTypeId type, Map&lt;String, Object&gt; configuration, List&lt;String&gt; inputs, List&lt;String&gt; outputs, Integer runOrder) {
<span class="fc" id="L356">        action.put(&quot;Name&quot;, actionName);</span>
<span class="fc bfc" id="L357" title="All 2 branches covered.">        action.compute(&quot;ActionTypeId&quot;, (String key, Object old) -&gt; CodePipelineUtils.convertActionTypeId(type != null ? type : old));</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">        if (!configuration.isEmpty()) {</span>
<span class="fc" id="L359">            action.put(&quot;Configuration&quot;, configuration);</span>
        }
<span class="fc bfc" id="L361" title="All 2 branches covered.">        if (!inputs.isEmpty()) {</span>
<span class="fc" id="L362">            action.put(&quot;InputArtifacts&quot;, inputs.stream().distinct().map(CodePipelineUtils::buildArtifactRef).collect(Collectors.toList()));</span>
        }
<span class="fc bfc" id="L364" title="All 2 branches covered.">        if (!outputs.isEmpty()) {</span>
<span class="fc" id="L365">            action.put(&quot;OutputArtifacts&quot;, outputs.stream().distinct().map(CodePipelineUtils::buildArtifactRef).collect(Collectors.toList()));</span>
        }
<span class="fc bfc" id="L367" title="All 2 branches covered.">        if (runOrder != null) {</span>
<span class="fc" id="L368">            action.put(&quot;RunOrder&quot;, runOrder);</span>
        }
<span class="fc" id="L370">        return action;</span>
    }

    /**
     * Builds webhook definition.
     *
     * @param config Pipeline configuration.
     * @param checkoutAction Checkout action name.
     * @return Resource definition.
     */
    private Map&lt;String, Object&gt; buildWebhookDefinition(PipelineConfiguraiton config, String checkoutAction) {
<span class="fc" id="L381">        var filter = new HashMap&lt;String, String&gt;();</span>
<span class="fc" id="L382">        filter.put(&quot;JsonPath&quot;, &quot;$.ref&quot;);</span>
<span class="fc" id="L383">        filter.put(&quot;MatchEquals&quot;, &quot;refs/heads/{Branch}&quot;);</span>
<span class="fc" id="L384">        var properties = new HashMap&lt;String, Object&gt;();</span>
<span class="fc" id="L385">        properties.put(&quot;Authentication&quot;, config.getWebhookAuthenticationType());</span>
<span class="fc" id="L386">        properties.put(&quot;AuthenticationConfiguration&quot;, Collections.singletonMap(&quot;SecretToken&quot;, config.getWebhookSecretToken()));</span>
<span class="fc" id="L387">        properties.put(&quot;TargetPipeline&quot;, TemplateUtils.ref(config.getResourceName()));</span>
<span class="fc" id="L388">        properties.put(&quot;TargetPipelineVersion&quot;, TemplateUtils.getAtt(config.getResourceName(), &quot;Version&quot;));</span>
<span class="fc" id="L389">        properties.put(&quot;TargetAction&quot;, checkoutAction);</span>
<span class="fc" id="L390">        properties.put(&quot;Filters&quot;, Collections.singletonList(filter));</span>
<span class="fc" id="L391">        properties.put(&quot;RegisterWithThirdParty&quot;, true);</span>
<span class="fc" id="L392">        return TemplateUtils.generateResource(&quot;CodePipeline::Webhook&quot;, properties, config.getHasCheckoutStepConditionName());</span>
    }

    /**
     * Builds condition based on Y/N parameter.
     *
     * @param param Parameter name.
     * @return Condition definition structure.
     */
    private static Map&lt;String, Object&gt; buildBooleanCondition(String param) {
<span class="fc" id="L402">        return Collections.singletonMap(&quot;Fn::Equals&quot;, Arrays.asList(TemplateUtils.ref(param), &quot;true&quot;));</span>
    }

    /**
     * Builds Fn::If call.
     *
     * @param condition Condition name.
     * @param whenTrue Value in case of positive case.
     * @param whenFalse Value in case of negative case.
     * @return Fn::If call.
     */
    private static Map&lt;String, Object&gt; fnIf(String condition, Object whenTrue, Object whenFalse) {
<span class="fc" id="L414">        return Collections.singletonMap(&quot;Fn::If&quot;, Arrays.asList(condition, whenTrue, whenFalse));</span>
    }

    /**
     * Template structure.
     */
    @SuppressWarnings(&quot;all&quot;)
    @lombok.Generated
    public Map&lt;String, Object&gt; getTemplate() {
        return this.template;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>