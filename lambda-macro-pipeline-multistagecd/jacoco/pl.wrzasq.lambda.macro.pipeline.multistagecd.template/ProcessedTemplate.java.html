<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ProcessedTemplate.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">WrzasqPl CodePipeline automation macro</a> &gt; <a href="index.source.html" class="el_package">pl.wrzasq.lambda.macro.pipeline.multistagecd.template</a> &gt; <span class="el_source">ProcessedTemplate.java</span></div><h1>ProcessedTemplate.java</h1><pre class="source lang-java linenums">// Generated by delombok at Mon Jul 06 01:51:43 UTC 2020
/*
 * This file is part of the pl.wrzasq.lambda.
 *
 * @license http://mit-license.org/ The MIT license
 * @copyright 2020 © by Rafał Wrzeszcz - Wrzasq.pl.
 */
package pl.wrzasq.lambda.macro.pipeline.multistagecd.template;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;
import java.util.stream.Collectors;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import pl.wrzasq.commons.aws.cloudformation.macro.TemplateDefinition;
import pl.wrzasq.commons.aws.cloudformation.macro.TemplateUtils;
import pl.wrzasq.commons.json.ObjectMapperFactory;
import pl.wrzasq.lambda.macro.pipeline.multistagecd.model.PipelineAction;
import pl.wrzasq.lambda.macro.pipeline.multistagecd.model.PipelineArtifact;
import pl.wrzasq.lambda.macro.pipeline.multistagecd.model.PipelineConfiguraiton;
import pl.wrzasq.lambda.macro.pipeline.multistagecd.model.PipelineDefinition;
import pl.wrzasq.lambda.macro.pipeline.multistagecd.model.PipelineStage;
import pl.wrzasq.lambda.macro.pipeline.multistagecd.model.codepipeline.ActionTypeId;

/**
 * Contains template structure after macro logic transformation.
 */
public class ProcessedTemplate implements TemplateDefinition {
    /**
     * Artificial &quot;Pipeline&quot; section.
     */
    private static final String SECTION_PIPELINE = &quot;Pipeline&quot;;
    /**
     * !Ref &quot;AWS::NoValue&quot; expression.
     */
<span class="fc" id="L45">    private static final Object NO_VALUE = TemplateUtils.ref(&quot;AWS::NoValue&quot;);</span>
    /**
     * CloudFormation artifact path separator.
     */
    private static final String ARTIFACT_SEPARATOR = &quot;::&quot;;
    /**
     * Values converter.
     */
<span class="fc" id="L53">    private static ObjectMapper objectMapper = ObjectMapperFactory.createObjectMapper();</span>
    /**
     * Logger.
     */
<span class="fc" id="L57">    private static Logger logger = LoggerFactory.getLogger(ProcessedTemplate.class);</span>
    /**
     * Template structure.
     */
    private Map&lt;String, Object&gt; template;

    /**
     * Template initializer.
     *
     * @param input Initial template structure.
     */
<span class="fc" id="L68">    public ProcessedTemplate(Map&lt;String, Object&gt; input) {</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">        this.template = input.containsKey(ProcessedTemplate.SECTION_PIPELINE) ? this.processTemplate(input) : </span>
        // nothing to process
<span class="fc" id="L71">        input;</span>
<span class="fc" id="L72">    }</span>

    /**
     * Builds pipeline resource.
     *
     * @param input Initial template structure.
     * @return Template state after processing.
     */
    private Map&lt;String, Object&gt; processTemplate(Map&lt;String, Object&gt; input) {
<span class="fc" id="L81">        logger.info(&quot;Found pipeline definition.&quot;);</span>
        // default values are set in the classes
<span class="fc" id="L83">        var pipeline = ProcessedTemplate.objectMapper.convertValue(input.get(ProcessedTemplate.SECTION_PIPELINE), PipelineDefinition.class);</span>
<span class="fc" id="L84">        input.remove(ProcessedTemplate.SECTION_PIPELINE);</span>
<span class="fc" id="L85">        var output = new HashMap&lt;&gt;(input);</span>
        // pipeline metadata setup
<span class="fc" id="L87">        output.put(TemplateUtils.SECTION_CONDITIONS, this.buildConditions(TemplateUtils.asMap(input.computeIfAbsent(TemplateUtils.SECTION_CONDITIONS, key -&gt; new HashMap&lt;&gt;())), pipeline.getConfig()));</span>
<span class="fc" id="L88">        output.put(TemplateUtils.SECTION_RESOURCES, this.buildResources(TemplateUtils.asMap(input.computeIfAbsent(TemplateUtils.SECTION_RESOURCES, key -&gt; new HashMap&lt;&gt;())), pipeline));</span>
<span class="fc" id="L89">        return output;</span>
    }

    /**
     * Builds conditions used by pipeline.
     *
     * @param conditions Initial conditions.
     * @param config Pipeline config.
     * @return Template conditions.
     */
    private Map&lt;String, Object&gt; buildConditions(Map&lt;String, Object&gt; conditions, PipelineConfiguraiton config) {
<span class="fc" id="L100">        conditions.put(config.getHasCheckoutStepConditionName(), ProcessedTemplate.buildBooleanCondition(config.getHasCheckoutStepParameterName()));</span>
<span class="fc" id="L101">        conditions.put(config.getHasNextStageConditionName(), ProcessedTemplate.buildBooleanCondition(config.getHasNextStageParameterName()));</span>
<span class="fc" id="L102">        conditions.put(config.getRequiresManualApprovalConditionName(), Collections.singletonMap(&quot;Fn::And&quot;, Arrays.asList(Collections.singletonMap(&quot;Condition&quot;, config.getHasNextStageConditionName()), ProcessedTemplate.buildBooleanCondition(config.getRequiresManualApprovalParameterName()))));</span>
<span class="fc" id="L103">        return conditions;</span>
    }

    /**
     * Builds resources used by pipeline.
     *
     * @param resources Resources container.
     * @param pipeline Pipeline definition.
     * @return Template conditions.
     */
    private Map&lt;String, Object&gt; buildResources(Map&lt;String, Object&gt; resources, PipelineDefinition pipeline) {
<span class="fc" id="L114">        var config = pipeline.getConfig();</span>
<span class="fc" id="L115">        resources.put(config.getResourceName(), this.buildPipelineDefinition(pipeline));</span>
        // GitHub webhook
<span class="pc bpc" id="L117" title="1 of 4 branches missed.">        if (config.getWebhookAuthenticationType() != null &amp;&amp; config.getWebhookSecretToken() != null) {</span>
<span class="fc" id="L118">            resources.put(String.format(&quot;%sWebhook&quot;, config.getResourceName()), this.buildWebhookDefinition(config, pipeline.getSources().keySet().iterator().next()));</span>
        }
<span class="fc" id="L120">        return resources;</span>
    }

    /**
     * Build pipeline definition.
     *
     * @param pipeline Pipeline definition.
     * @return Resource definition.
     */
    private Map&lt;String, Object&gt; buildPipelineDefinition(PipelineDefinition pipeline) {
<span class="fc" id="L130">        var config = pipeline.getConfig();</span>
<span class="fc" id="L131">        var artifacts = pipeline.getArtifacts();</span>
<span class="fc" id="L132">        var stages = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L133">        stages.add(this.buildSourceStage(config, pipeline.getSources(), artifacts));</span>
<span class="fc" id="L134">        stages.addAll(this.buildStages(pipeline.getStages()));</span>
<span class="fc" id="L135">        stages.add(this.buildManualApprovalStage(config));</span>
<span class="fc" id="L136">        stages.add(this.buildPromoteStage(config, artifacts));</span>
        // finalize properties
<span class="fc" id="L138">        var properties = new HashMap&lt;&gt;(pipeline.getProperties());</span>
<span class="fc" id="L139">        properties.put(&quot;Stages&quot;, stages);</span>
<span class="fc" id="L140">        return TemplateUtils.generateResource(&quot;CodePipeline::Pipeline&quot;, properties, null);</span>
    }

    /**
     * Builds sources stage.
     *
     * @param config Pipeline configuration.
     * @param sources Source locations.
     * @param artifacts Previous stage artifacts.
     * @return Stage definition.
     */
    private Map&lt;String, Object&gt; buildSourceStage(PipelineConfiguraiton config, Map&lt;String, Map&lt;String, Object&gt;&gt; sources, Map&lt;String, PipelineArtifact&gt; artifacts) {
<span class="fc" id="L152">        return CodePipelineUtils.buildStage(&quot;Source&quot;, ProcessedTemplate.fnIf(config.getHasCheckoutStepConditionName(), this.buildCheckoutSources(sources), this.buildPromotedSources(artifacts)));</span>
    }

    /**
     * Builds sources action steps.
     *
     * @param sources Source locations.
     * @return Stage actions.
     */
    private Object buildCheckoutSources(Map&lt;String, Map&lt;String, Object&gt;&gt; sources) {
<span class="fc" id="L162">        var steps = new ArrayList&lt;&gt;(sources.size());</span>
        // keeping order to avoid structure changes in CloudFormation
<span class="fc bfc" id="L164" title="All 2 branches covered.">        for (var id : new TreeSet&lt;&gt;(sources.keySet())) {</span>
<span class="fc" id="L165">            steps.add(ProcessedTemplate.buildActionDefinition(sources.get(id), PipelineAction.builder().name(id).outputs(Collections.singletonList(id)).build()));</span>
<span class="fc" id="L166">        }</span>
<span class="fc" id="L167">        return steps;</span>
    }

    /**
     * Builds sources action steps.
     *
     * @param artifacts Previous stage artifacts.
     * @return Stage actions.
     */
    private Object buildPromotedSources(Map&lt;String, PipelineArtifact&gt; artifacts) {
<span class="fc" id="L177">        var steps = new ArrayList&lt;&gt;(artifacts.size());</span>
<span class="fc" id="L178">        var runOrder = 0;</span>
<span class="fc" id="L179">        var type = ActionTypeId.s3Source();</span>
        /*
        having sources in reverse direction than in promote step, makes us sure that each next stage pipeline is
        launched only when all previous stage artifacts are properly uploaded
         */
<span class="fc bfc" id="L184" title="All 2 branches covered.">        for (var id : new TreeSet&lt;&gt;(artifacts.keySet()).descendingSet()) {</span>
<span class="fc" id="L185">            var artifact = artifacts.get(id);</span>
<span class="fc" id="L186">            var actionConfig = new HashMap&lt;String, Object&gt;();</span>
<span class="fc" id="L187">            actionConfig.put(&quot;S3Bucket&quot;, artifact.getSourceBucketName());</span>
<span class="fc" id="L188">            actionConfig.put(&quot;S3ObjectKey&quot;, artifact.getObjectKey());</span>
<span class="fc" id="L189">            steps.add(ProcessedTemplate.buildActionDefinition(PipelineAction.builder().name(id).type(type).configuration(actionConfig).outputs(Collections.singletonList(id)).runOrder(++runOrder).build()));</span>
<span class="fc" id="L190">        }</span>
<span class="fc" id="L191">        return steps;</span>
    }

    /**
     * Builds pipelines stage definition.
     *
     * @param stages Stages definitions.
     * @return Stages definition.
     */
    private List&lt;Object&gt; buildStages(List&lt;PipelineStage&gt; stages) {
<span class="fc bfc" id="L201" title="All 2 branches covered.">        return stages.stream().map(stage -&gt; stage.getCondition() == null ? this.buildStage(stage) : ProcessedTemplate.fnIf(stage.getCondition(), this.buildStage(stage), ProcessedTemplate.NO_VALUE)).collect(Collectors.toList());</span>
    }

    /**
     * Builds manual approval stage definition.
     *
     * @param config Pipeline configuration.
     * @return Stage definition.
     */
    private Object buildManualApprovalStage(PipelineConfiguraiton config) {
<span class="fc" id="L211">        return ProcessedTemplate.fnIf(config.getRequiresManualApprovalConditionName(), CodePipelineUtils.buildStage(&quot;Review&quot;, Collections.singletonList(ProcessedTemplate.buildActionDefinition(PipelineAction.builder().name(&quot;Approval&quot;).type(ActionTypeId.manualApproval()).build()))), ProcessedTemplate.NO_VALUE);</span>
    }

    /**
     * Builds artifacts promotion stage definition.
     *
     * @param config Pipeline configuration.
     * @param artifacts Artifacts configuration.
     * @return Stage definition.
     */
    private Object buildPromoteStage(PipelineConfiguraiton config, Map&lt;String, PipelineArtifact&gt; artifacts) {
<span class="fc" id="L222">        var steps = new ArrayList&lt;&gt;(artifacts.size());</span>
<span class="fc" id="L223">        var runOrder = 0;</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">        for (var id : new TreeSet&lt;&gt;(artifacts.keySet())) {</span>
<span class="fc" id="L225">            var artifact = artifacts.get(id);</span>
<span class="fc" id="L226">            var type = ActionTypeId.s3Deploy();</span>
<span class="fc" id="L227">            var actionConfig = new HashMap&lt;String, Object&gt;();</span>
<span class="fc" id="L228">            actionConfig.put(&quot;BucketName&quot;, artifact.getNextBucketName());</span>
<span class="fc" id="L229">            actionConfig.put(&quot;ObjectKey&quot;, artifact.getObjectKey());</span>
<span class="fc" id="L230">            actionConfig.put(&quot;Extract&quot;, false);</span>
            // this shifts ownership to target account in case (usual scenario) of cross-account deployment
<span class="fc" id="L232">            actionConfig.put(&quot;CannedACL&quot;, &quot;bucket-owner-full-control&quot;);</span>
<span class="fc" id="L233">            steps.add(ProcessedTemplate.buildActionDefinition(PipelineAction.builder().name(id).type(type).configuration(actionConfig).inputs(Collections.singletonList(id)).runOrder(++runOrder).build()));</span>
<span class="fc" id="L234">        }</span>
<span class="fc" id="L235">        return ProcessedTemplate.fnIf(config.getHasNextStageConditionName(), CodePipelineUtils.buildStage(&quot;Promote&quot;, steps), ProcessedTemplate.NO_VALUE);</span>
    }

    /**
     * Builds pipeline stage definition structure.
     *
     * @param stage Stage setup.
     * @return CodePipeline stage definition.
     */
    private Map&lt;String, Object&gt; buildStage(PipelineStage stage) {
<span class="fc" id="L245">        var actions = stage.getActions();</span>
<span class="fc" id="L246">        actions.forEach(ProcessedTemplate::normalizeAction);</span>
<span class="fc" id="L247">        ProcessedTemplate.orderActions(actions);</span>
<span class="fc" id="L248">        return CodePipelineUtils.buildStage(stage.getName(), actions.stream().map(ProcessedTemplate::buildActionDefinition).collect(Collectors.toList()));</span>
    }

    /**
     * Normalizes all actions.
     *
     * @param action Action setup.
     */
    private static void normalizeAction(PipelineAction action) {
<span class="fc bfc" id="L257" title="All 2 branches covered.">        if (action.getType() == null) {</span>
<span class="fc" id="L258">            action.setType(ActionTypeId.cloudFormationDeploy());</span>
        }
<span class="fc" id="L260">        action.setInputs(ProcessedTemplate.detectInputArtifacts(action));</span>
<span class="fc" id="L261">    }</span>

    /**
     * Orders all actions.
     *
     * @param actions Stage actions.
     */
    private static void orderActions(List&lt;PipelineAction&gt; actions) {
<span class="fc" id="L269">        var visited = new HashSet&lt;PipelineAction&gt;();</span>
<span class="fc" id="L270">        var outputs = new HashMap&lt;String, PipelineAction&gt;();</span>
<span class="fc" id="L271">        actions.forEach(action -&gt; action.getOutputs().forEach(input -&gt; outputs.put(input, action)));</span>
<span class="fc" id="L272">        actions.forEach(action -&gt; ProcessedTemplate.calculateActionOrder(action, visited, outputs));</span>
<span class="fc" id="L273">    }</span>

    /**
     * Calculates action order.
     *
     * @param action Current subject action.
     * @param visited Current state markers.
     * @param outputs Output artifacts mapping.
     */
    private static void calculateActionOrder(PipelineAction action, Set&lt;PipelineAction&gt; visited, Map&lt;String, PipelineAction&gt; outputs) {
        // already calculated
<span class="fc bfc" id="L284" title="All 2 branches covered.">        if (action.getRunOrder() != null) {</span>
<span class="fc" id="L285">            return;</span>
        }
<span class="fc bfc" id="L287" title="All 2 branches covered.">        if (visited.contains(action)) {</span>
<span class="fc" id="L288">            throw new IllegalArgumentException(String.format(&quot;Circular artifact dependency for %s.&quot;, action.getName()));</span>
        }
<span class="fc" id="L290">        visited.add(action);</span>
        
        // dependencies from outside of stage not need to be considered
<span class="fc bfc" id="L293" title="All 2 branches covered.">        action.getInputs().stream().filter(outputs::containsKey).peek(input -&gt; ProcessedTemplate.calculateActionOrder(outputs.get(input), visited, outputs)).map(input -&gt; outputs.get(input).getRunOrder()).mapToInt(order -&gt; (order == null ? 1 : order) + 1).max().ifPresent(action::setRunOrder);</span>
<span class="fc" id="L294">        visited.remove(action);</span>
<span class="fc" id="L295">    }</span>

    /**
     * Builds list of all used input artifacts.
     *
     * @param action Action definition.
     * @return List of input artifacts.
     */
    private static List&lt;String&gt; detectInputArtifacts(PipelineAction action) {
<span class="fc" id="L304">        var inputs = action.getInputs();</span>
        // check TemplatePath source artifact
<span class="fc" id="L306">        var config = action.getConfiguration();</span>
<span class="fc" id="L307">        var value = config.get(&quot;TemplatePath&quot;);</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">        if (value instanceof String) {</span>
<span class="fc" id="L309">            inputs.add(((String) value).split(ProcessedTemplate.ARTIFACT_SEPARATOR)[0]);</span>
        }
        // check TemplateConfiguration source artifact
<span class="fc" id="L312">        value = config.get(&quot;TemplateConfiguration&quot;);</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">        if (value instanceof String) {</span>
<span class="fc" id="L314">            inputs.add(((String) value).split(ProcessedTemplate.ARTIFACT_SEPARATOR)[0]);</span>
        }
<span class="fc" id="L316">        return inputs;</span>
    }

    /**
     * Populates pipeline action definition structure.
     *
     * @param action Action configuration.
     * @return CodePipeline stage definition.
     */
    private static Map&lt;String, Object&gt; buildActionDefinition(PipelineAction action) {
<span class="fc" id="L326">        return ProcessedTemplate.buildActionDefinition(new HashMap&lt;&gt;(), action);</span>
    }

    /**
     * Populates pipeline action definition structure.
     *
     * @param data Initial definition.
     * @param action Action configuration.
     * @return CodePipeline stage definition.
     */
    private static Map&lt;String, Object&gt; buildActionDefinition(Map&lt;String, Object&gt; data, PipelineAction action) {
<span class="fc" id="L337">        data.put(&quot;Name&quot;, action.getName());</span>
<span class="fc bfc" id="L338" title="All 2 branches covered.">        data.compute(&quot;ActionTypeId&quot;, (String key, Object old) -&gt; CodePipelineUtils.convertActionTypeId(action.getType() != null ? action.getType() : old));</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">        if (action.getRegion() != null) {</span>
<span class="fc" id="L340">            data.put(&quot;Region&quot;, action.getRegion());</span>
        }
<span class="fc bfc" id="L342" title="All 2 branches covered.">        if (!action.getConfiguration().isEmpty()) {</span>
<span class="fc" id="L343">            data.put(&quot;Configuration&quot;, action.getConfiguration());</span>
        }
<span class="fc bfc" id="L345" title="All 2 branches covered.">        if (!action.getInputs().isEmpty()) {</span>
<span class="fc" id="L346">            data.put(&quot;InputArtifacts&quot;, ProcessedTemplate.buildArtifactRefs(action.getInputs()));</span>
        }
<span class="fc bfc" id="L348" title="All 2 branches covered.">        if (!action.getOutputs().isEmpty()) {</span>
<span class="fc" id="L349">            data.put(&quot;OutputArtifacts&quot;, ProcessedTemplate.buildArtifactRefs(action.getOutputs()));</span>
        }
<span class="fc bfc" id="L351" title="All 2 branches covered.">        if (action.getRunOrder() != null) {</span>
<span class="fc" id="L352">            data.put(&quot;RunOrder&quot;, action.getRunOrder());</span>
        }
<span class="fc" id="L354">        return data;</span>
    }

    /**
     * Builds webhook definition.
     *
     * @param config Pipeline configuration.
     * @param checkoutAction Checkout action name.
     * @return Resource definition.
     */
    private Map&lt;String, Object&gt; buildWebhookDefinition(PipelineConfiguraiton config, String checkoutAction) {
<span class="fc" id="L365">        var filter = new HashMap&lt;String, String&gt;();</span>
<span class="fc" id="L366">        filter.put(&quot;JsonPath&quot;, &quot;$.ref&quot;);</span>
<span class="fc" id="L367">        filter.put(&quot;MatchEquals&quot;, &quot;refs/heads/{Branch}&quot;);</span>
<span class="fc" id="L368">        var properties = new HashMap&lt;String, Object&gt;();</span>
<span class="fc" id="L369">        properties.put(&quot;Authentication&quot;, config.getWebhookAuthenticationType());</span>
<span class="fc" id="L370">        properties.put(&quot;AuthenticationConfiguration&quot;, Collections.singletonMap(&quot;SecretToken&quot;, config.getWebhookSecretToken()));</span>
<span class="fc" id="L371">        properties.put(&quot;TargetPipeline&quot;, TemplateUtils.ref(config.getResourceName()));</span>
<span class="fc" id="L372">        properties.put(&quot;TargetPipelineVersion&quot;, TemplateUtils.getAtt(config.getResourceName(), &quot;Version&quot;));</span>
<span class="fc" id="L373">        properties.put(&quot;TargetAction&quot;, checkoutAction);</span>
<span class="fc" id="L374">        properties.put(&quot;Filters&quot;, Collections.singletonList(filter));</span>
<span class="fc" id="L375">        properties.put(&quot;RegisterWithThirdParty&quot;, true);</span>
<span class="fc" id="L376">        return TemplateUtils.generateResource(&quot;CodePipeline::Webhook&quot;, properties, config.getHasCheckoutStepConditionName());</span>
    }

    /**
     * Builds condition based on Y/N parameter.
     *
     * @param param Parameter name.
     * @return Condition definition structure.
     */
    private static Map&lt;String, Object&gt; buildBooleanCondition(String param) {
<span class="fc" id="L386">        return Collections.singletonMap(&quot;Fn::Equals&quot;, Arrays.asList(TemplateUtils.ref(param), &quot;true&quot;));</span>
    }

    /**
     * Converts artifact names into list of artifact reference.
     *
     * @param names Artifact names.
     * @return Artifact references.
     */
    private static List&lt;Map&lt;String, String&gt;&gt; buildArtifactRefs(Collection&lt;String&gt; names) {
<span class="fc" id="L396">        return names.stream().distinct().map(CodePipelineUtils::buildArtifactRef).collect(Collectors.toList());</span>
    }

    /**
     * Builds Fn::If call.
     *
     * @param condition Condition name.
     * @param whenTrue Value in case of positive case.
     * @param whenFalse Value in case of negative case.
     * @return Fn::If call.
     */
    private static Map&lt;String, Object&gt; fnIf(String condition, Object whenTrue, Object whenFalse) {
<span class="fc" id="L408">        return Collections.singletonMap(&quot;Fn::If&quot;, Arrays.asList(condition, whenTrue, whenFalse));</span>
    }

    /**
     * Template structure.
     */
    @SuppressWarnings(&quot;all&quot;)
    @lombok.Generated
    public Map&lt;String, Object&gt; getTemplate() {
        return this.template;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>